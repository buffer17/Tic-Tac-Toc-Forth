( точка в начале слова используетс€ как соглашение дл€ обозначени€ того, что слово св€зано с выводом ( печатью информации )
: .stack_del ( n1 .. nk -- )		( ¬ывод стека с очищением)
	depth dup 0= if		\ ѕроверка на нулевой стек
		drop cr ." Error(-4): .stack_del stack underflow " ABORT
	then
	DROP			\ ”дал€ем верхний элемент стека ( повторный depth )
	depth 0 do
		.
	loop ;

variable n_
: .stack ( n1 .. nk -- n1 .. nk )	( ¬ывод стека без очищени€)
	depth dup 0= if		\ ѕроверка на нулевой стек
		drop cr ." Error(-4): .stack_del stack underflow " ABORT
	then
	DROP			\ ”дал€ем верхний элемент стека ( повторный depth )
	depth n_ ! 		\ сохран€ем исходную глубину стека
	n_ @ 0 do
		i pick .	\ копируем элемент с индексом i и выводим его
	loop ;

( @ ( фетч  используетс€ дл€ извлечени€ ( чтени€ значени€ из пам€ти по указанному адресу
ƒругими словаи, если вы имеете переменную или €чейку пам€ти, то @ берет адрес этой переменной со стека и считывает оттуда сохраненное значение,
помеща€ его на вершину стека )
( ! (store дл€ хранени€
  @ (fetch дл€ извлечени€ )

( ќчистка стека)
: .sd ( n1 .. nk -- )
	depth 0= if
		drop ." empty  ok " ABORT
	then
	depth 0 do drop loop ." clear " ;

( ќчистка стека без вывода )
: .sd_n ( n1 .. nk -- )
	depth 0= if
		drop ABORT
	then
	depth 0 do drop loop ;
